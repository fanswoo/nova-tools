<template>
  <b-modal v-model="searchBoxDisplay" hide-footer no-fade @hide="onCloseModal">
    <template v-slot:modal-title>
      {{ title }}
    </template>
    <div class="setting-box">
      <template v-for="(field, key) in searchSettingFields" :key="key">
        <component
          :is="field.type"
          class="input-area"
          @onChange="changeResult"
          v-bind="field"
          :value="searchSettingFields[key].value"
        />
      </template>
    </div>
  </b-modal>
</template>

<script setup lang="ts">
import { ref, onMounted, watch, getCurrentInstance, inject, computed } from 'vue';
import { ComponentLoader } from '@fanswoo/component-loader/main';
import _ from 'lodash';

const props = defineProps({
  searchSettingFields: {
    type: Object,
    default: () => ({}),
  },
  title: {
    type: String,
    default: '更多設置',
  }
});
const injectUrlRootPath = inject('urlRootPath');

const vueInstance = getCurrentInstance();
const route = computed(() => vueInstance.proxy.$route);
const router = computed(() => vueInstance.proxy.$router);
const searchBoxDisplay = ref(false);

const Loader = ComponentLoader.getInstance();
if(!vueInstance.proxy.$.components) {
  vueInstance.proxy.$.components = [];
}
_.merge(vueInstance.proxy.$.components, Loader.loadComponents([
  {
    pageName: injectUrlRootPath,
    themeName: 'listCustomComponent',
    typeName: 'searchBox',
  },
]));

onMounted(() => {

  if (route.value.query.searchBoxDisplay === null) {
    searchBoxDisplay.value = true;
  }

  router.value.afterEach((to, from) => {
    checkSearchBoxDisplayByRoute(to);
  });
});

function onCloseModal() {
  closeSearchBoxDisplay();
}

function checkSearchBoxDisplayByRoute(to) {
  let value = to.query.searchBoxDisplay;
  if (value === null) {
    searchBoxDisplay.value = true;
  } else {
    searchBoxDisplay.value = false;
  }
}

function openSearchBoxDisplay() {
  let query = _.cloneDeep(route.value.query);
  query.searchBoxDisplay = null;

  router.value.push({
    path: route.value.path,
    query: query,
  }).catch((error) => {});
}

function closeSearchBoxDisplay() {
  let query = _.cloneDeep(route.value.query);
  delete query.searchBoxDisplay;

  router.value.push({
    path: route.value.path,
    query: query,
  }).catch((error) => {});
}

function changeResult(payload) {
  for (let key in props.searchSettingFields) {
    if (props.searchSettingFields[key].inputName == payload.inputName) {
      props.searchSettingFields[key].value = payload.value;
      emit('changeResult', {
        key: key,
        text: props.searchSettingFields[key].value,
        value: props.searchSettingFields[key].value,
      });
    }
  }
}

watch(() => route.value.query.searchBoxDisplay, (newValue, oldValue) => {
  if (newValue === null) {
    searchBoxDisplay.value = true;
  } else {
    searchBoxDisplay.value = false;
  }
}, { immediate: true });

defineExpose({
  openSearchBoxDisplay,
  closeSearchBoxDisplay,
});
</script>

