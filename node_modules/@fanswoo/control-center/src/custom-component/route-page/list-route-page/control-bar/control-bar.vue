<template>
  <div class="control-bar">
    <component
      :is="listComponents.FixedButtons"
      v-if="isMobile && fixedButtons"
      :buttons="fixedButtons"
      @onClick="onFixedButtonClick"
    />
    <component
      :is="listComponents.SearchModal"
      v-if="isMobile"
      ref="searchModal"
      :searchSettingFields="searchSettingFields"
      @changeResult="changeResult"
    />
    <component
      :is="listComponents.SearchBox"
      v-if="!isMobile"
      ref="searchBox"
      :searchSettingFields="searchSettingFields"
      @changeResult="changeResult"
      :scrollFixed="scrollFixed"
    />
    <div :class="{ 'control-bar-body': true, fixed: scrollFixed }">
      <div class="control-content">
        <div
          v-if="isSettingButtonDisplay && !isMobile"
          class="setting-button"
          @click="onSettingButtonClick"
        ></div>
        <component
          :is="listComponents.ControlButtons"
          v-if="
            !isMobile &&
            ControlCenter.ControlButton &&
            ControlCenter.ControlButton.buttons
          "
          :buttons="ControlCenter.ControlButton.buttons"
          :searchSettingFieldValues="searchSettingFieldValues"
        />
        <component
          :is="listComponents.BatchSelect"
          v-if="ControlCenter && ControlCenter.BatchSelect"
          :batchSelectText="ControlCenter.BatchSelect.batchSelectText"
          :batchSelectOptions="ControlCenter.batchSelectOptions"
          :onlyTrashed="onlyTrashed"
          :totalCount="totalCount"
          :selectedCount="selectedCount"
          :ORMCheckedIds="ORMCheckedIds"
        />
        <component
          :is="listComponents.SearchContent"
          :searchSettingFields="searchSettingFields"
          @changeResult="changeResult"
        />
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, inject, computed, watchEffect, getCurrentInstance } from 'vue';
import { debounce, merge } from 'lodash'; // Assuming lodash is available
import { ComponentLoader } from '@fanswoo/component-loader/main';

// Props definitions
const props = defineProps({
  listComponents: {
    type: Object,
    default: () => ({
      SearchBox: '',
      SearchModal: '',
      FixedButtons: '',
      ControlButtons: '',
      BatchSelect: '',
      SearchContent: '',
    }),
  },
  scrollFixed: {
    type: [String, Number, Boolean],
    default: null,
  },
  ControlCenter: {
    type: Object,
    default: () => ({
      ControlButton: {
        buttons: [],
      },
    }),
  },
  onlyTrashed: {
    type: Boolean,
    default: false,
  },
  totalCount: {
    type: Number,
    default: 0,
  },
  selectedCount: {
    type: Number,
    default: 0,
  },
  ORMCheckedIds: {
    type: Array,
    default: () => ([]),
  },
  searchSettingFields: {
    type: Object,
    default: () => ({}),
  }
});

const emit = defineEmits(['changeResult']);

// Reactive data
const vueInstance = getCurrentInstance();
const isMobile = ref(false);
const searchBox = ref(null);
const searchModal = ref(null);
const urlRootPath = inject('urlRootPath'); // Assuming injection key is provided somewhere

// Computed properties
const fixedButtons = computed(() => {
  let fixedButtons = [];
  if (props.ControlCenter.ControlButton && props.ControlCenter.ControlButton.buttons) {
    for (let key in props.ControlCenter.ControlButton.buttons) {
      fixedButtons.push(props.ControlCenter.ControlButton.buttons[key]);
    }
    fixedButtons.push({ key: 'setting', fontAwesomeIcon: 'cog' });
  }
  return fixedButtons;
});

const isSettingButtonDisplay = computed(() => {
  if (!props.ControlCenter || !props.searchSettingFields) {
    return false;
  }

  for (let field in props.searchSettingFields) {
    if (props.searchSettingFields[field].type !== 'hidden' && props.searchSettingFields[field].type !== 'display') {
      return true;
    }
  }
  return false;
});

const searchSettingFieldValues = computed(() => {
  let values = {};
  for (let key in props.searchSettingFields) {
    let field = props.searchSettingFields[key];
    if (field.inputName && field.value) {
      values[field.inputName] = field.value;
    }
  }
  return values;
});

// Methods
const onFixedButtonClick = (payload) => {
  if (payload.key === 'setting') {
    searchModal.value.openSearchBoxDisplay();
  }
};

const onSettingButtonClick = () => {
  searchBox.value.settingButtonClick();
};

const changeResult = (field) => {
  emit('changeResult', {
    key: field.key,
    text: field.key,
    value: field.value,
  });
};

const isMobileCheck = () => {
  if (window.innerWidth < 768) {
    isMobile.value = true;
  } else {
    isMobile.value = false;
  }
};

isMobileCheck();
const resizeObserver = new ResizeObserver(entries => {
  debounce(isMobileCheck, 300)();
});

const bodyContentPage = document.querySelector('.body-content-page');
if (bodyContentPage) {
  resizeObserver.observe(bodyContentPage);
}

const Loader = ComponentLoader.getInstance();
if(!vueInstance.proxy.$.components) {
  vueInstance.proxy.$.components = [];
}
_.merge(vueInstance.proxy.$.components, Loader.loadComponents([
  {
    pageName: urlRootPath,
    themeName: 'listCustomComponent',
    typeName: 'layout',
  },
  {
    pageName: urlRootPath,
    themeName: 'layout',
    typeName: 'layout',
  },
]));

watchEffect(() => {
  // Example of usage, adjust according to actual need
});
</script>

